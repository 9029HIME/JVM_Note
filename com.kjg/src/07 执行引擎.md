# 执行引擎的作用

![image](https://user-images.githubusercontent.com/48977889/157137337-21628ec2-41ee-4a06-bef6-192f098ac2d7.png)

JVM的主要任务是将类的字节码加载到内存中，操作系统本身不认识字节码，因此需要执行殷勤解释字节码到对应平台（Windows、Linux、MacOS）的机器码，然后执行。相当于**充当了高级语言转换为机器语言的翻译者**。

执行引擎需要执行什么指令，这个依赖于PC寄存器（JVM层面的PC），在方法的执行过程中，执行引擎可能会通过局部变量表中的指针快速定位到堆中的对象实例，并且通过对象实例的对象头中的元数据指针快速定位到这个对象的class对象。

![image](https://user-images.githubusercontent.com/48977889/157171858-419e1ab4-bfc7-4aed-8aec-ede1c69effb1.png)

Java早期是一门解释型语言，后期本质是一门半解释、半编译型语言，JVM执行引擎包含**解释执行**与**编译执行**两种模式。解释执行指的是执行引擎**一行一行地**把字节码翻译成机器码执行的过程，类似于

```
forEach(x -> {	complie(x);	execute(x);	});
```

编译执行指的是执行引擎直接将**源代码**编译成机器码，然后将这段机器码缓存到元空间，最后拿来直接执行的过程，类似于 

```
var jitResult = complie(y);
jitResult.forEach(x -> {	execute(x);	});
```

编译执行依赖于JIT（Just In Time）编译器。

# JIT

为什么JIT和解释器要共存？解释器虽然比JIT慢，但是在Java进程启动后，解释器能够省去编译时间，立刻翻译字节码去执行。如果像JRockit VM那样完全抛弃解释器，那么Java进程的启动时间会变得很慢（需要先编译、后执行）。相反，当Java进程运行了足够长的时间后，许多方法的执行都稳定下来并且重复执行，如果每次都以来解释执行必然会导致性能下降，这时候JIT的作用就出来了。JIT将热点代码进行编译，转换成机器码后存到方法区内。当再次调用方法只需执行，无需解释，**JIT和解释器的共存形成了一种性能上的平衡**。而且，如果JIT激进优化不成立的时候，解释器可以作为一个后备方案继续执行指令。