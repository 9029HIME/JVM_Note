# 标记阶段

要回收垃圾，首先要确定哪些是垃圾对象。

## 引用计数器算法

1. 比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
2. 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
3. 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
4. 缺点：
   1. 它需要单独的字段存储计数器，这样的做法增加了**存储空间的开销**。
   2. 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了**时间开销**。
   3. 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，**导致在Java的垃圾回收器中没有使用这类算法**。

## 可达性分析算法

![cc31973c82aa85437defd5de391e581](https://user-images.githubusercontent.com/48977889/158817139-0a1052c4-d4a0-4bfd-a960-6cada65626b3.jpg)

JVM规定一组**引用**集合，这个集合被称为GC Roots。以GC Roots为起点自上而下搜索根对象集合所连接的目标对象是否可达，如果可达则对象存活，不可达则垃圾对象。比起引用技术法，可达性分析算法能解决循环引用的问题。**不过要注意！！GC Root本质是一组引用，可以理解为二级指针，不是对象，它并非存在堆内**，如图：

![915fa696d1867888fafe591fdf07ce4](https://user-images.githubusercontent.com/48977889/158816831-5d45595d-895e-4645-a05a-52d3b5f0f767.jpg)

GC Roots包含以下范围：
1.虚拟机栈、本地方法栈存放的引用，如局部变量表存放的引用
2.静态属性的引用
3.静态常量属性的引用
4.等等...
总的来说，不在堆空间的引用都可以作为GC Roots的一部分。但除了这些固定的GC Roots外，有些垃圾回收器会根据回收区域不同，**将一些堆内的引用临时加入GC Roots内**，比如只针对eden区的垃圾回收。如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

# Finalize

垃圾回收期在标记对象后，销毁对象前，会调用这个对象的Object::finalize()方法，调用完成后再判断这个对象是否值得被销毁，如果对象变得可达，则不标记销毁，反之则继续销毁。通常finalize()方法是用来销毁对象前做一些资源关闭处理，有点类似C++的析构函数。不过深入理解Java虚拟机说过：**finalize()设计之初是为了满足C/C++开发人员的习惯。所以在日常的开发中，关闭资源还是在finally代码块里写比较好。**
具体的finalize过程：
1.在可达性分析后，发现GC Roots到对象a没有引用链，标记对象a为**不可达状态**。
2.对象a是否重写了finalize() ? 进入第三步 : 等待被销毁
3.对象a是否执行过finalize() ? 进入不可达状态 : 进入**可复活状态**，进行第四步
4.将对象a插入F-Queue内，一个由虚拟机创建的、低优先级的Finalizer线程会根据队列顺序，执行对象的finalize()方法。
5.执行完对象a的finalize()方法后，垃圾回收器会对对象a进行第二次标记，如果发现对象a在GC Roots上可达，则将对象a移出垃圾对象集合，并把对象a标记为**可达状态**。如果不可达，则标记为**不可达状态**。

**从头到尾，1个对象finalize()要么不执行，要么就只执行1次。**

# 清除阶段