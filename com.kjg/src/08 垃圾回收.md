# 标记阶段

要回收垃圾，首先要确定哪些是垃圾对象。

## 引用计数器算法

1. 比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
2. 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
3. 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
4. 缺点：
   1. 它需要单独的字段存储计数器，这样的做法增加了**存储空间的开销**。
   2. 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了**时间开销**。
   3. 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，**导致在Java的垃圾回收器中没有使用这类算法**。

## 可达性分析算法

![cc31973c82aa85437defd5de391e581](https://user-images.githubusercontent.com/48977889/158817139-0a1052c4-d4a0-4bfd-a960-6cada65626b3.jpg)

JVM规定一组**引用**集合，这个集合被称为GC Roots。以GC Roots为起点自上而下搜索根对象集合所连接的目标对象是否可达，如果可达则对象存活，不可达则垃圾对象。比起引用技术法，可达性分析算法能解决循环引用的问题。**不过要注意！！GC Root本质是一组引用，可以理解为二级指针，不是对象，它并非存在堆内**，如图：

![915fa696d1867888fafe591fdf07ce4](https://user-images.githubusercontent.com/48977889/158816831-5d45595d-895e-4645-a05a-52d3b5f0f767.jpg)

GC Roots包含以下范围：
1.虚拟机栈、本地方法栈存放的引用，如局部变量表存放的引用
2.静态属性的引用
3.静态常量属性的引用
4.等等...
总的来说，不在堆空间的引用都可以作为GC Roots的一部分。但除了这些固定的GC Roots外，有些垃圾回收器会根据回收区域不同，**将一些堆内的引用临时加入GC Roots内**，比如只针对eden区的垃圾回收。如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

# Finalize

垃圾回收期在标记对象后，销毁对象前，会调用这个对象的Object::finalize()方法，调用完成后再判断这个对象是否值得被销毁，如果对象变得可达，则不标记销毁，反之则继续销毁。通常finalize()方法是用来销毁对象前做一些资源关闭处理，有点类似C++的析构函数。不过深入理解Java虚拟机说过：**finalize()设计之初是为了满足C/C++开发人员的习惯。所以在日常的开发中，关闭资源还是在finally代码块里写比较好。**
具体的finalize过程：
1.在可达性分析后，发现GC Roots到对象a没有引用链，标记对象a为**不可达状态**。
2.对象a是否重写了finalize() ? 进入第三步 : 等待被销毁
3.对象a是否执行过finalize() ? 进入不可达状态 : 进入**可复活状态**，进行第四步
4.将对象a插入F-Queue内，一个由虚拟机创建的、低优先级的Finalizer线程会根据队列顺序，执行对象的finalize()方法。
5.执行完对象a的finalize()方法后，垃圾回收器会对对象a进行第二次标记，如果发现对象a在GC Roots上可达，则将对象a移出垃圾对象集合，并把对象a标记为**可达状态**。如果不可达，则标记为**不可达状态**。

**从头到尾，1个对象finalize()要么不执行，要么就只执行1次。**

# 清除阶段

首先要搞明白，标记阶段是明确**哪些对象是存活对象**，毕竟垃圾对象在很多时候是无法确定的。标记实际上就是往**非垃圾对象**的对象头上标识一个**可达状态**，之后就是清除了。清除阶段主要是对堆中（**或者GC范围中**）的对象进行线性遍历，如果发现这个对象的对象头状态记录**不是可达状态**，就认为它是垃圾对象。目前主流用到三种清除算法：标记清除（Mark-Sweep）、标记复制（Mark-Copy）、标记压缩（Mark-Sweep-Compact）

## 标记清除

分为两个**整体**的流程：标记和清除。首先通过标记算法标记出哪些对象可达，这是第一次循环。然后再从根节点为起点，遍历堆中（或者GC范围中）的对象，当发现这个对象**不是可达状态**时，释放这个对象的空间，这是第二次循环。如图：

![60e2658965b531f8698ce60937975fb](https://user-images.githubusercontent.com/48977889/159280510-e715d37f-013b-473c-8240-b9c20aac36d9.jpg)

实际上，这里的清除并非物理上释放内存空间，而是标记这块内存区域为可用，**等下次需要对象赋值时，直接覆盖这块区域**。总的来看标记清除算法的时间复杂度是O(2n)，这也导致了STW时间更长。优点是简单方便，缺点就是效率偏低，而且会造成内存碎片。

## 标记复制

标记复制算法需要划分两块内存区域，同一时间段内只能使用其中一块内存区域，另一外内存区域置空。在进行**标记复制**回收时，先从根节点开始遍历，将遍历到的对象采用**指针碰撞**的方式移动到另一块内存区域内，遍历结束后**需要改变原有二级指针记录的存活对象地址（毕竟换了一个内存区域）**，释放原先内存区域的垃圾对象空间，同时**交换两块内存区域的角色**。如图：

![03d1d24c386a987c753521f85d09474](https://user-images.githubusercontent.com/48977889/159280999-b7583b0f-5835-4c21-904f-1e9ec0b74731.jpg)

比起标记清除算法，标记复制算法的优点体现在：减少了一次循环，相当于减少了STW的时间。并且不会产生内存碎片，毕竟存活对象转移到另一块区域时用的是指针碰撞。缺点是浪费了一块内存区域，**并且不适用于存活对象多的场景（存活对象越少，效率越高）**。

## 标记压缩

标记压缩算法和标记清除算法有点类似，也是需要两步，分别是标记和压缩。首先通过标记算法标记出哪些对象可达，这是第一次循环。接着通过**压缩算法**将存活对象紧密地排列在一起，随后清除**标记范围里，其他区域的所有对象**（都是垃圾了），然后改变原有二级指针记录的存活对象地址，最后JVM会为**标记范围**维护一个起始地址，下次分配对象时根据起始地址碰撞就能得出新对象的地址了。

值得一提的是，这里的**压缩算法**只是一笔带过，实际上在标记结束后，不是简单地再次遍历，然后压缩，**其实是有一番讲究的**。总之最终的效果和标记复制算法一样，没有产生内存碎片，但和标记清除又有点像，都是只用一块内存区域来完成GC。但是缺点也很明显，首先是效率问题，**压缩算法**是一个比较复杂的过程，不好的压缩算法会导致STW时间很长。总体上来看，标记压缩算法是三个算法里效率最低的。

## 三种算法的对比

|              | 标记清除           | 标记整理           | 复制                                  |
| ------------ | ------------------ | ------------------ | ------------------------------------- |
| **速率**     | 中等               | 最慢               | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片）   | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是（需要更换地址） | 是（需要更换地址）                    |

# 分代收集算法

