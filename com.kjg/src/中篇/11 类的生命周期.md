# 类的加载

本质上就是将字节码文件的内存加载到JVM内存中，并且在方法区（逻辑概念）构建出字节码文件对应的类原型，即类在JVM中的一个快照。JVM从字节码文件中解析出**常量池、类字段、类方法**等信息存储到类原型中，**再通过类原型创建class对象**，这样JVM就可以在运行期间通过class对象，找到类原型获取类的所有信息，这也是反射的基础支持。（class对象是基于类原型派生的，两个不是同一个概念）

![image](https://user-images.githubusercontent.com/48977889/162555131-62af15a6-b25c-4294-b89c-0e1872fadf46.png)

对于类加载器来说，它只关心将字节码文件的**二进制流**加载代JVM内存中，过程是：1.获取二进制流	2.解析二进制流的数据，转换为类原型 	3.创建类原型的对象，即class对象。对于二进制流的获取，基本都是通过全类名在文件系统中读取，也有读取jar包获取，也有将二进制数据存入数据库中读取（很少见），也有通过网络请求获取（很少见）。**当然，也少不了运行时直接动态生成字节码二进制流，这是动态代理的基础支撑之一**。

也不是所有的二进制流都会被类加载器加到JVM内存中，加载之前需要校验流数据的合法性，比较经典的校验过程之一就是流文件开头的CA FE BA BE。

不过数组比较特殊，数组作为一个特殊的引用结构，**数组类**的信息不是由类加载器负责加载到JVM内存的，而是有JVM在运行时动态生成、创建的。

# 类的链接

## 验证

主要是对类信息做初步的验证，主要内容包括类信息的格式验证、语义检查、字节码验证、符号引用验证等。虽然验证是放在链接步骤上，但实际上**格式验证（验证的第一步）是和加载阶段一起运行的**，只有通过验证后，类加载器才会加载对应的字节码文件。**其他的验证则是类加载完成后，在方法区上进行**。

1.格式验证：字节码文件是否以CA FE BA BE开头、版本号是否与JVM声明的一致，数据长度范围是否准确。

2.语义检查：类信息在语法上是否符合Java语法规范要求。

3.字节码验证：判断字节码是否能正确被运行，是否会在运行过程中跳到一条不存在的指令，验证函数调用的参数类型，变量赋值的数据类型是否一致等等...主要是防止前端编译后，人为修改的错误字节码在JVM上运行。栈映射帧就是在这个阶段使用，主要是用来检测特定的字节码在运行时，**局部变量表和操作数栈是否有着正确的数据类型**

实际上经过了上面3个检查，只能保证校验失败的字节码文件是有问题的，但即使校验通过了，也不能100%确保没问题。

4.符号引用验证：字节码文件在其常量池会通过符号引用记录自己要用到的其他类、方法，**这个阶段的验证是保证这些类和方法是存在的，并且有权限访问**。这个验证只会在**解析阶段**进行。

## 解析



