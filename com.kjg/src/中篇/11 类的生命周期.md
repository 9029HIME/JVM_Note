# 类的加载

本质上就是将字节码文件的内存加载到JVM内存中，并且在方法区（逻辑概念）构建出字节码文件对应的类原型，即类在JVM中的一个快照。JVM从字节码文件中解析出**常量池、类字段、类方法**等信息存储到类原型中，**再通过类原型创建class对象**，这样JVM就可以在运行期间通过class对象，找到类原型获取类的所有信息，这也是反射的基础支持。（class对象是基于类原型派生的，两个不是同一个概念）

![image](https://user-images.githubusercontent.com/48977889/162555131-62af15a6-b25c-4294-b89c-0e1872fadf46.png)

对于类加载器来说，它只关心将字节码文件的**二进制流**加载代JVM内存中，过程是：1.获取二进制流	2.解析二进制流的数据，转换为类原型 	3.创建类原型的对象，即class对象。对于二进制流的获取，基本都是通过全类名在文件系统中读取，也有读取jar包获取，也有将二进制数据存入数据库中读取（很少见），也有通过网络请求获取（很少见）。**当然，也少不了运行时直接动态生成字节码二进制流，这是动态代理的基础支撑之一**。

也不是所有的二进制流都会被类加载器加到JVM内存中，加载之前需要校验流数据的合法性，比较经典的校验过程之一就是流文件开头的CA FE BA BE。

不过数组比较特殊，数组作为一个特殊的引用结构，**数组类**的信息不是由类加载器负责加载到JVM内存的，而是有JVM在运行时动态生成、创建的。

# 类的链接

## 验证

主要是对类信息做初步的验证，主要内容包括类信息的格式验证、语义检查、字节码验证、符号引用验证等。

虽然验证是放在链接步骤上，但实际上**格式验证（验证的第一步）是和加载阶段一起运行的**，只有通过验证后，类加载器才会加载对应的字节码文件。**其他的验证则是类加载完成后，在方法区上进行**。

1.格式验证：字节码文件是否以CA FE BA BE开头、版本号是否与JVM声明的一致，数据长度范围是否准确。

2.语义检查：类信息在语法上是否符合Java语法规范要求。

3.字节码验证：判断字节码是否能正确被运行，是否会在运行过程中跳到一条不存在的指令，验证函数调用的参数类型，变量赋值的数据类型是否一致等等...主要是防止前端编译后，人为修改的错误字节码在JVM上运行。栈映射帧就是在这个阶段使用，主要是用来检测特定的字节码在运行时，**局部变量表和操作数栈是否有着正确的数据类型**

实际上经过了上面3个检查，只能保证校验失败的字节码文件是有问题的，但即使校验通过了，也不能100%确保没问题。

4.符号引用验证：字节码文件在其常量池会通过符号引用记录自己要用到的其他类、方法，**这个阶段的验证是保证这些类和方法是存在的，并且有权限访问**。这个验证只会在**解析阶段**进行。

## 准备

为**静态变量**分配内存，赋默认初始化值。

对于boolean来说内部实现是int，因为int的默认值是0，所以boolean的默认值也是false。值得注意的是，对于非静态变量的值在加载阶段就会被加载到类原型上，在类的生命周期里是不会初始化的，它只针对对象的生命周期内。不过对于**基本数据类型字面、String字面**的静态常量（static final），在准备阶段就会显示赋值了。

## 解析

将**字节码指令**中类、接口、方法、属性的符号引用，转变为直接引用。

字节码文件里的常量池保存了这个类使用到的字面量和符号引用的**具体直接引用，或者下一层符号引用**。

- 假如A引用B（具体的实现类），编译阶段编译A的时候，是无法知道B是否被编译的，所以编译阶段B会被符号所代替，这个符号就是B的地址。在解析的时候如果B尚未加载，就会加载B，此时A中的符号将替换成真正的B的地址，这种称为静态解析，此时的解析是在初始化之前发生。
- 如果A引用的是B的抽象方法或者接口。那么只有在调用A的时候才知道具体的实现类是哪一个。此时的解析是发生在初始化之后的，也被成为动态解析。
- 虚拟机可以对第一次的解析结果进行缓存，避免解析动作的重复执行。

一般来说，**解析**是在**初始化**之后才执行的，只是大方向上属于链接的一部分。

# 类的初始化

为**静态变量**赋予正确的值，并执行类中定义好的Java程序代码。

在初始化阶段，最重要的是执行clinit方法， 可以理解为class的init方法，即类的初始化方法。clinit只能被Java编译器生成，被JVM调用，方法内容由静态变量的赋值内容、static语句块构成，赋值内容与static语句块的具体执行顺序由代码顺序决定。

实际上，在加载类之前，总会先加载该类的父类，因此父类的clinit总会比该类的clinit先执行。

当然，有些类是没有自身的clinit的，比如一个类本身没有声明静态变量、没有声明**静态变量的的赋值**、没有声明静态代码块、声明的静态变量在**准备**阶段已赋值了。

上篇也说到，，JVM采用了锁同步的方式保证clinit的执行是线程安全的，如果clint过程中包含了阻塞，则会拖慢JVM的启动，甚至引起死锁。

# 类的使用

类的使用分为主动使用和被动使用，只有在主动使用的场景下，类的clinit会被调用。也就是说：主动使用-类会被初始化，被动使用-类不会被初始化，但加载通常都会做的。

主动使用的场景：

1. 通过new、反射、克隆、反序列化创建类的实例对象。

2. 调用该类的直接静态方法。

3. 使用该类**会执行初始化**的静态字段（具体看**准备**的显示赋值条件）。

4. 该类是父类，其子类要初始化时。但是初始化一个类时，其类实现的**没有default属性的接口**不会初始化，初始化一个接口时，父接口不会被初始化。

5. main类。

被动使用的场景：

1. 使用该类的父类静态字段。
2. 创建该类的数组 如 A[] arr = new A[10]; **但操作数组内的数据属于主动使用**。
3. 使用该类**不会执行初始化**的静态字段。
4. 调用类加载器的loadClass()方法加载一个类，本质只是加载，不会导致初始化。

# 类的卸载

总结一句：基本无法被卸载，也不要基于卸载的前提下开发功能。

类卸载的前提：要卸载的类的class对象是垃圾对象。

![image](https://user-images.githubusercontent.com/48977889/162601461-6dcc9432-6b9d-4d00-a74b-b554fe17c8e6.png)
