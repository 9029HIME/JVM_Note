# 垃圾回收器的分类与性能指标

## 回收器分类

垃圾回收器可以从多个维度进行分类，按工作模式分，可以分成串行垃圾回收器、并行垃圾回收器、并发垃圾回收器

![image](https://user-images.githubusercontent.com/48977889/160401272-d67d0f53-f09e-4d63-b842-67b95fc85bf3.png)

串行垃圾回收器：只有一个线程负责GC，STW时停止所有用户线程（已过时）。

![image](https://user-images.githubusercontent.com/48977889/160401306-8638ceee-cb63-472b-a753-a19dd3024be9.png)

并行垃圾回收器：可以有多个线程**同时负责GC**，但是STW的时候还是要停止所有用户线程。

![image](https://user-images.githubusercontent.com/48977889/160401357-01b5bb79-f549-4429-ad96-9478280a6797.png)

并发垃圾回收器：执行垃圾回收器的线程可以和用户线程交替执行（GC回收的区域和用户线程的使用区域没有交集）。

如果按照内存碎片处理方式区分，又可以分成压缩式垃圾回收器和非压缩式垃圾回收器。两者的区别不言而喻。

如果按照工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。

## 性能指标

衡量一个回收器的算法性能如何，主要通过**吞吐量**和**STW暂停时间**来判断。

吞吐量指的是：运行用户代码时间 /（运行用户代码时间+垃圾收集时间），即分母是总运行时间。

STW暂停时间指的是垃圾回收器在GC阶段，STW导致用户线程暂停的时间。

然而实际上，高吞吐量和低暂停时间是矛盾的，两者不可得兼，具体如下：

![a8cd485474bfb15bdd87db0d1ae0d2d](https://user-images.githubusercontent.com/48977889/160402750-c335c520-1250-4501-a419-198a5826a1ac.jpg)

如果同一时间内，对同样数量的垃圾进行回收，采用高吞吐量的做法是：减少GC次数，增加单次GC所需耗时，这样总的GC耗时相对较少，整体上看系统的吞吐量就高。如果采用低暂停时间的做法，必然会导致GC次数增加，**因为GC这个行为本身就会消耗性能，所以不会因为减少了时间，增加了次数后，暂停时间的总时和高吞吐量做法一样**，即总的时间上看，低暂停时间的做法会导致吞吐率下降。但是低暂停时间能够提高响应速度与用户体验，**特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。**

## 垃圾回收器的介绍

首先回顾垃圾回收器的发展史：

1. 1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本
2. 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·
3. Parallel GC在JDK6之后成为HotSpot默认GC。
4. 2012年，在JDK1.7u4版本中，G1可用。
5. 2017年，JDK9中G1变成默认的垃圾收集器。
6. 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。
7. 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 "No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）
8. 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。
9. 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。
10. 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用

总的来说

有Serial GC（串行）、CMS（并发）、Parallel Scavenge（并行新生代）、Parallel Old（并行老年代）、G1（并发）、Epsilon、ZGC

JDK8：默认使用Parallel Scavenge 和 Parallel Old 两款垃圾回收器的结合。

JDK9：默认使用G1垃圾回收器。

JDK10：对G1进行优化

JDK12：增强G1

JDK13：增强ZGC

JDK14：拓展了ZGC

**目前2022年大部分都在用JDK8，也就是说中期范围内更多是使用Parallel Scavenge+Parallel Old，将来会考虑G1，在长期角度考虑会使用ZGC。**

垃圾回收器之间的分区使用范围和搭配使用策略是：

![image](https://user-images.githubusercontent.com/48977889/160406294-890e931c-f4b0-4518-a525-d8abdc9cbc6f.png![737df7a1109837197a492ab56182ccf](https://user-images.githubusercontent.com/48977889/160406541-74ed6996-999b-48b7-b03f-fad486efba3d.jpg)

1. 两个收集器间有连线，表明它们可以搭配使用：
   - Serial/Serial old
   - Serial/CMS （JDK9废弃）
   - ParNew/Serial Old （JDK9废弃）
   - ParNew/CMS
   - Parallel Scavenge/Serial Old （预计废弃）
   - Parallel Scavenge/Parallel Old
   - G1
2. 其中Serial Old作为CMS出现"Concurrent Mode Failure"失败的后备预案。
3. （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。
4. （绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）
5. （青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）
6. 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。
7. 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以**我们选择的只是对具体应用最合适的收集器**。

# Serial垃圾回收器

是最基本、历史最悠久的垃圾回收器（**基本不会用了**），针对于新生代的回收，配合Serial Old进行老年代的回收。Serial回收器采用**标记复制算法**，Serial Old采用标记压缩算法。他们俩都是Client模式下默认算法。 Serial 与 Serial Old是典型的**串行垃圾回收器**，在GC阶段**只会有一个线程负责**，并且暂停其他所有用户线程。

![image](https://user-images.githubusercontent.com/48977889/160539369-02d3b6fc-b9d4-465e-9fbe-485399ca4c07.png)

# ParNew垃圾回收器

是并行垃圾回收器，只能处理新生代的垃圾，底层也是使用**标记复制算法**，主要和Serial Old或CMS搭配使用。不过JDK9后Serial Old不能与ParNew搭配使用了，JDK14后CMS也被移除了，也就是说**将来ParNew基本不会被使用了**。下图考虑的是与Serial Old的搭配：

![image](https://user-images.githubusercontent.com/48977889/160540810-b3f8e501-c10e-4249-a9f2-b03d6f2d4a21.png)

默认情况下，ParNew的GC线程数与CPU逻辑核数一样。

# Parallel垃圾回收器

分为Parallel Scavenge和Parallel Old，分别对应新生代和老年代，