# 垃圾回收器的分类与性能指标

## 回收器分类

垃圾回收器可以从多个维度进行分类，按工作模式分，可以分成串行垃圾回收器、并行垃圾回收器、并发垃圾回收器

![image](https://user-images.githubusercontent.com/48977889/160401272-d67d0f53-f09e-4d63-b842-67b95fc85bf3.png)

串行垃圾回收器：只有一个线程负责GC，STW时停止所有用户线程（已过时）。

![image](https://user-images.githubusercontent.com/48977889/160401306-8638ceee-cb63-472b-a753-a19dd3024be9.png)

并行垃圾回收器：可以有多个线程**同时负责GC**，但是STW的时候还是要停止所有用户线程。

![image](https://user-images.githubusercontent.com/48977889/160401357-01b5bb79-f549-4429-ad96-9478280a6797.png)

并发垃圾回收器：执行垃圾回收器的线程可以和用户线程交替执行（GC回收的区域和用户线程的使用区域没有交集）。

如果按照内存碎片处理方式区分，又可以分成压缩式垃圾回收器和非压缩式垃圾回收器。两者的区别不言而喻。

如果按照工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。

## 性能指标

衡量一个回收器的算法性能如何，主要通过**吞吐量**和**STW暂停时间**来判断。

吞吐量指的是：运行用户代码时间 /（运行用户代码时间+垃圾收集时间），即分母是总运行时间。

STW暂停时间指的是垃圾回收器在GC阶段，STW导致用户线程暂停的时间。

然而实际上，高吞吐量和低暂停时间是矛盾的，两者不可得兼，具体如下：

![a8cd485474bfb15bdd87db0d1ae0d2d](https://user-images.githubusercontent.com/48977889/160402750-c335c520-1250-4501-a419-198a5826a1ac.jpg)

如果同一时间内，对同样数量的垃圾进行回收，采用高吞吐量的做法是：减少GC次数，增加单次GC所需耗时，这样总的GC耗时相对较少，整体上看系统的吞吐量就高。如果采用低暂停时间的做法，必然会导致GC次数增加，**因为GC这个行为本身就会消耗性能，所以不会因为减少了时间，增加了次数后，暂停时间的总时和高吞吐量做法一样**，即总的时间上看，低暂停时间的做法会导致吞吐率下降。但是低暂停时间能够提高响应速度与用户体验，**特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。**

## 垃圾回收器的介绍

首先回顾垃圾回收器的发展史：

1. 1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本
2. 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·
3. Parallel GC在JDK6之后成为HotSpot默认GC。
4. 2012年，在JDK1.7u4版本中，G1可用。
5. 2017年，JDK9中G1变成默认的垃圾收集器。
6. 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。
7. 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 "No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）
8. 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。
9. 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。
10. 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用

总的来说

有Serial GC（串行）、CMS（并发）、Parallel Scavenge（并行新生代）、Parallel Old（并行老年代）、G1（并发）、Epsilon、ZGC

JDK8：默认使用Parallel Scavenge 和 Parallel Old 两款垃圾回收器的结合。

JDK9：默认使用G1垃圾回收器。

JDK10：对G1进行优化

JDK12：增强G1

JDK13：增强ZGC

JDK14：拓展了ZGC

**目前2022年大部分都在用JDK8，也就是说中期范围内更多是使用Parallel Scavenge+Parallel Old，将来会考虑G1，在长期角度考虑会使用ZGC。**

垃圾回收器之间的分区使用范围和搭配使用策略是：

![image](https://user-images.githubusercontent.com/48977889/160406294-890e931c-f4b0-4518-a525-d8abdc9cbc6f.png![737df7a1109837197a492ab56182ccf](https://user-images.githubusercontent.com/48977889/160406541-74ed6996-999b-48b7-b03f-fad486efba3d.jpg)

1. 两个收集器间有连线，表明它们可以搭配使用：
   - Serial/Serial old
   - Serial/CMS （JDK9废弃）
   - ParNew/Serial Old （JDK9废弃）
   - ParNew/CMS
   - Parallel Scavenge/Serial Old （预计废弃）
   - Parallel Scavenge/Parallel Old
   - G1
2. 其中Serial Old作为CMS出现"Concurrent Mode Failure"失败的后备预案。
3. （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。
4. （绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）
5. （青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）
6. 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。
7. 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以**我们选择的只是对具体应用最合适的收集器**。

# Serial垃圾回收器

是最基本、历史最悠久的垃圾回收器（**基本不会用了**），针对于新生代的回收，配合Serial Old进行老年代的回收。Serial回收器采用**标记复制算法**，Serial Old采用标记压缩算法。他们俩都是Client模式下默认算法。 Serial 与 Serial Old是典型的**串行垃圾回收器**，在GC阶段**只会有一个线程负责**，并且暂停其他所有用户线程。

![image](https://user-images.githubusercontent.com/48977889/160539369-02d3b6fc-b9d4-465e-9fbe-485399ca4c07.png)

# ParNew垃圾回收器

是并行垃圾回收器，只能处理新生代的垃圾，底层也是使用**标记复制算法**，主要和Serial Old或CMS搭配使用。不过JDK9后Serial Old不能与ParNew搭配使用了，JDK14后CMS也被移除了，也就是说**将来ParNew基本不会被使用了**。下图考虑的是与Serial Old的搭配：

![image](https://user-images.githubusercontent.com/48977889/160540810-b3f8e501-c10e-4249-a9f2-b03d6f2d4a21.png)

默认情况下，ParNew的GC线程数与CPU逻辑核数一样。

# Parallel垃圾回收器

分为Parallel Scavenge和Parallel Old，分别对应新生代和老年代，他俩都是并行垃圾回收器，底层分别采用标记复制、标记压缩算法。同时也是JDK8默认的垃圾回收器。

![image](https://user-images.githubusercontent.com/48977889/160845039-b45c46ce-79a1-4b9c-b6a3-cf148840888b.png)

比起ParNew算法，Parallel算法最大的有点是**注重吞吐量**，可以高效率地利用CPU时间，尽快完成程序的运算任务，**主要适合在后台运算而不需要太多交互的任务**。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。

对于**Parallel Scavenge**算法来说，可以通过-XX:GCTimeRatio来设置STW时间与运行时间的总占比，用来平衡吞吐量的大小。当然，可以通过-XX:MaxGCPauseMillis时间设置尽可能靠拢的STW最大时间，以此降低延迟性，但这样会牺牲吞吐量。如果实在觉得麻烦，也可以使用-XX:+UseAdaptiveSizePolicy开启自动调节策略，该策略可以使年轻代大小、eden区和幸存者区的比例、GC age的值**动态地调整大小**，从而在堆大小、吞吐量、STW时间之间找到最平衡的点。

# CMS

Concurrent-Mark-Sweep，它是老年代的垃圾回收器，采用标记清除算法，**是少有的并发垃圾回收器**。CMS更关注尽可能地减少STW的停顿时间，从而使用户交互更加流畅，对于服务端来说会比较好用。尴尬的是，CMS只能与Serial，ParNew搭配使用，但这两个年轻代垃圾回收器已经很少使用了。

对于CMS来说，只要分3步：

![image](https://user-images.githubusercontent.com/48977889/160852672-0c860b0f-2669-45ff-9fbf-fd7fadfc2891.png)

1.串行级别的初始**标记**，在这个阶段只是为了找到当前GC Roots能**直接关联的对象**，因此耗时很短。

2.并发级别的**标记**：从GC Roots开始遍历整个对象图，**标记可达对象**，虽然耗时比较长，但是因为和用户线程一起并发运行，所以显得没什么延迟，**顶多是性能稍微下降一点**。

3.并行级别的重新**标记**：由于在2.并发标记的过程中，有部分对象的引用关系可能会变了，因此需要挂起所有用户线程，展开并行阶段的重新标记。但是在2.阶段已经标记了挺多，引用关系发生变化的情况也不是频繁发生，加上是并发执行的效率，这个阶段的STW时间不会很长。

4.并发级别的**清除**：经过3.的重新标记后，系统内的可达对象已经可以基本确定下来，此时GC线程与用户线程并发，开始清除不可达对象。由于采用的是**标记清除算法**，在清除过程中对象的位置不会发生改变，因此和用户线程并发运行时**不会引起数据一致性问题**。

由于GC阶段CMS线程和用户线程会并发运行，如果在GC过程中用户线程需要分配一个大对象，而内存又没有足够空间接收时，会抛出Concurrent Mode Failure，此时就要搬出后备方案Serial Old垃圾回收器，但它又是一个串行的垃圾回收器，可以说是迫不得已只能摆烂的做法。所以CMS不能像其他垃圾回收器一样等到内存快用满了才回收，而是定一个阈值，超过这个阈值了便触发CMS GC。作为标记清除算法的实现，自然少不了内存碎片的产生，虽然最后是交给Serial Old来擦屁股了。

不过有一点值得留意，CMS无法处理浮动垃圾。回到上面的步骤，2.采用并发级别的标记，在GC线程标记的同时，用户线程也会改变对象间的引用关系，但无非就两种：1.可达对象 → 不可达对象 2.不可达对象 → 可达对象。这也是为什么需要3.的重新标记，但是！！！重新标记只能把原本是垃圾，后来变可用的对象标记上，**但原本是可用，后面变垃圾的对象就无能为力了**，在CMS眼里，它认为这些对象仍是可达的，所以清除阶段也不会清除这些对象，只能等待下一次CMS GC去标记。

总的来说：

1.内存碎片。

2.需要提前开始GC，还要用Serial Old来兜底。

3.浮动垃圾需要等待下一轮清除。