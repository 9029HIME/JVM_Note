# 垃圾回收器的分类与性能指标

## 回收器分类

垃圾回收器可以从多个维度进行分类，按工作模式分，可以分成串行垃圾回收器、并行垃圾回收器、并发垃圾回收器

![image](https://user-images.githubusercontent.com/48977889/160401272-d67d0f53-f09e-4d63-b842-67b95fc85bf3.png)

串行垃圾回收器：只有一个线程负责GC，STW时停止所有用户线程（已过时）。

![image](https://user-images.githubusercontent.com/48977889/160401306-8638ceee-cb63-472b-a753-a19dd3024be9.png)

并行垃圾回收器：可以有多个线程**同时负责GC**，但是STW的时候还是要停止所有用户线程。

![image](https://user-images.githubusercontent.com/48977889/160401357-01b5bb79-f549-4429-ad96-9478280a6797.png)

并发垃圾回收器：执行垃圾回收器的线程可以和用户线程交替执行（GC回收的区域和用户线程的使用区域没有交集）。

如果按照内存碎片处理方式区分，又可以分成压缩式垃圾回收器和非压缩式垃圾回收器。两者的区别不言而喻。

如果按照工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。

## 性能指标

衡量一个回收器的算法性能如何，主要通过**吞吐量**和**STW暂停时间**来判断。

吞吐量指的是：运行用户代码时间 /（运行用户代码时间+垃圾收集时间），即分母是总运行时间。

STW暂停时间指的是垃圾回收器在GC阶段，STW导致用户线程暂停的时间。

然而实际上，高吞吐量和低暂停时间是矛盾的，两者不可得兼，具体如下：

![a8cd485474bfb15bdd87db0d1ae0d2d](https://user-images.githubusercontent.com/48977889/160402750-c335c520-1250-4501-a419-198a5826a1ac.jpg)

如果同一时间内，对同样数量的垃圾进行回收，采用高吞吐量的做法是：减少GC次数，增加单次GC所需耗时，这样总的GC耗时相对较少，整体上看系统的吞吐量就高。如果采用低暂停时间的做法，必然会导致GC次数增加，**因为GC这个行为本身就会消耗性能，所以不会因为减少了时间，增加了次数后，暂停时间的总时和高吞吐量做法一样**，即总的时间上看，低暂停时间的做法会导致吞吐率下降。但是低暂停时间能够提高响应速度与用户体验，**特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。**

## 垃圾回收器的介绍

首先回顾垃圾回收器的发展史：

1. 1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本
2. 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·
3. Parallel GC在JDK6之后成为HotSpot默认GC。
4. 2012年，在JDK1.7u4版本中，G1可用。
5. 2017年，JDK9中G1变成默认的垃圾收集器。
6. 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。
7. 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 "No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）
8. 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。
9. 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。
10. 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用

总的来说

有Serial GC（串行）、CMS（并发）、Parallel Scavenge（并行新生代）、Parallel Old（并行老年代）、G1（并发）、Epsilon、ZGC

JDK8：默认使用Parallel Scavenge 和 Parallel Old 两款垃圾回收器的结合。

JDK9：默认使用G1垃圾回收器。

JDK10：对G1进行优化

JDK12：增强G1

JDK13：增强ZGC

JDK14：拓展了ZGC

**目前2022年大部分都在用JDK8，也就是说中期范围内更多是使用Parallel Scavenge+Parallel Old，将来会考虑G1，在长期角度考虑会使用ZGC。**

垃圾回收器之间的分区使用范围和搭配使用策略是：

![image](https://user-images.githubusercontent.com/48977889/160406294-890e931c-f4b0-4518-a525-d8abdc9cbc6f.png![737df7a1109837197a492ab56182ccf](https://user-images.githubusercontent.com/48977889/160406541-74ed6996-999b-48b7-b03f-fad486efba3d.jpg)

1. 两个收集器间有连线，表明它们可以搭配使用：
   - Serial/Serial old
   - Serial/CMS （JDK9废弃）
   - ParNew/Serial Old （JDK9废弃）
   - ParNew/CMS
   - Parallel Scavenge/Serial Old （预计废弃）
   - Parallel Scavenge/Parallel Old
   - G1
2. 其中Serial Old作为CMS出现"Concurrent Mode Failure"失败的后备预案。
3. （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。
4. （绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）
5. （青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）
6. 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。
7. 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以**我们选择的只是对具体应用最合适的收集器**。

# Serial垃圾回收器

是最基本、历史最悠久的垃圾回收器（**基本不会用了**），针对于新生代的回收，配合Serial Old进行老年代的回收。Serial回收器采用**标记复制算法**，Serial Old采用标记压缩算法。他们俩都是Client模式下默认算法。 Serial 与 Serial Old是典型的**串行垃圾回收器**，在GC阶段**只会有一个线程负责**，并且暂停其他所有用户线程。

![image](https://user-images.githubusercontent.com/48977889/160539369-02d3b6fc-b9d4-465e-9fbe-485399ca4c07.png)

# ParNew垃圾回收器

是并行垃圾回收器，只能处理新生代的垃圾，底层也是使用**标记复制算法**，主要和Serial Old或CMS搭配使用。不过JDK9后Serial Old不能与ParNew搭配使用了，JDK14后CMS也被移除了，也就是说**将来ParNew基本不会被使用了**。下图考虑的是与Serial Old的搭配：

![image](https://user-images.githubusercontent.com/48977889/160540810-b3f8e501-c10e-4249-a9f2-b03d6f2d4a21.png)

默认情况下，ParNew的GC线程数与CPU逻辑核数一样。

# Parallel垃圾回收器

分为Parallel Scavenge和Parallel Old，分别对应新生代和老年代，他俩都是并行垃圾回收器，底层分别采用标记复制、标记压缩算法。同时也是JDK8默认的垃圾回收器。

![image](https://user-images.githubusercontent.com/48977889/160845039-b45c46ce-79a1-4b9c-b6a3-cf148840888b.png)

比起ParNew算法，Parallel算法最大的有点是**注重吞吐量**，可以高效率地利用CPU时间，尽快完成程序的运算任务，**主要适合在后台运算而不需要太多交互的任务**。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。

对于**Parallel Scavenge**算法来说，可以通过-XX:GCTimeRatio来设置STW时间与运行时间的总占比，用来平衡吞吐量的大小。当然，可以通过-XX:MaxGCPauseMillis时间设置尽可能靠拢的STW最大时间，以此降低延迟性，但这样会牺牲吞吐量。如果实在觉得麻烦，也可以使用-XX:+UseAdaptiveSizePolicy开启自动调节策略，该策略可以使年轻代大小、eden区和幸存者区的比例、GC age的值**动态地调整大小**，从而在堆大小、吞吐量、STW时间之间找到最平衡的点。

# CMS

Concurrent-Mark-Sweep，它是老年代的垃圾回收器，采用标记清除算法，**是少有的并发垃圾回收器**。CMS更关注尽可能地减少STW的停顿时间，从而使用户交互更加流畅，对于服务端来说会比较好用。尴尬的是，CMS只能与Serial，ParNew搭配使用，但这两个年轻代垃圾回收器已经很少使用了。

对于CMS来说，只要分3步：

![image](https://user-images.githubusercontent.com/48977889/160852672-0c860b0f-2669-45ff-9fbf-fd7fadfc2891.png)

M

1.内存碎片。

2.需要提前开始GC，还要用Serial Old来兜底。

3.浮动垃圾需要等待下一轮清除。

# G1（现阶段的未来）

G1有三种GC：Young GC（仅针对eden、s1、s2）、Mix GC（整个年轻代、部分老年代）、Full GC（单线程串行式，摆烂兜底做法），对于正常流程的G1来说，没有传统的Major GC，它针对老年代的GC只有部分老年代+整个年轻代的回收做法。不过JDK10后，G1的Full GC变成了多线程并行式。

G1和前面的内存设计不一样，以前的垃圾回收器中，认为堆内存是连续的逻辑空间，并且可以连续的划分出年轻代、老年代，就像堆章节中对于内存的划分图一样。但是对于G1垃圾回收器来说，Java堆内存是被等额划分为不同的区域（region）。

![image](https://user-images.githubusercontent.com/48977889/161671577-b39b13c9-93bd-465f-93ac-d4f1fe454136.png)

每一个region的内存大小都一样，每一个region都能代表为分区，总的来说region分为五种分区：空白区、伊甸园、幸存者、老年代、巨大对象。伊甸园、幸存者、老年代和之前的定义没什么区别，空白区指的是未被分配对象、也未划分定义的区域。巨大对象区只能用来存放大对象，**当对象的大小超过region大小的50%时，就会被分配到巨大对象区域。**值得注意的是，region的分区属性**并非一成不变**的，比如发生Young GC后那些伊甸园区的对象会移动到to区，原先的from区就会变成空白区域，原来的空白区域摇身一变成了to区：

![image](https://user-images.githubusercontent.com/48977889/161672273-78cf319a-dcf6-4ff0-beef-af96d4ac6614.png)

这样的设计，使得G1回收器**既有标记复制算法、又有标记整理算法的特性**，这一点和以前的GC就有很明显的不同了，以前的GC都是围绕着连续的区域，将堆划分成不同的**代**，针对这些代进行垃圾回收。而G1却是将堆分割出一块一块的region，针对这些region进行分代，**同一代的region在逻辑上不是连续的，并且同一个region在不同时间内可以充当不同代**，这是一个本质上的改变。

![image](https://user-images.githubusercontent.com/48977889/161674380-8a71f914-152a-4de3-8a36-0c256e40d713.png)

对于一个region来说，可以分为两个区域：已分配、未分配。在给region内分配对象的时候，实际采用了指针碰撞的方式，先预定义一个对象的大小（这个可以直接算出来），然后根据大小挪动指针就完事了，当发现算出来的值已经大于阈值，直接将对象放到humongous区域里。

对于  G1回收器，有以下参数可以配置：

- XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务
- -XX:G1HeapRegionSize：设置每个region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。

- -XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms
- -XX:+ParallelGCThread：设置STW工作线程数的值。最多设置为8

## G1的回收过程

先说结论：**G1回收器既有并行、又有并发回收的特性**

首先G1每一次回收，在保证stw时间的前提下，会先根据region的优先级，按顺序选择一部分一起回收，当然，如果stw范围内能全部回收完就都回收，但实际情况下只能选前面的一部分。这个优先级的依据是：**region内的垃圾对象越多，这个region的优先级越高**。当这个region被回收后一般会将存活对象**复制并压缩到另一个region上**，这就意味着原先的region变为空闲了。G1会为空间region维护一个空闲链表，当region经过gc变得空闲后，就会被加入到这个空闲链表内。

对于同一个JVM，同一个时刻来说，只能对一个region进行分配操作，这个region也被称为current region。在多线程的场景下current region会引发数据一致性问题， 这里就结合之前堆章节中讲到的TLAB了。当开启TLAB时，线程A初始化的时候会在eden region创建初始化一块TLAB区域，**当线程A创建的对象大于它的tlab大小、或者GC开始标记对象的时候**，TLAB会回归eden region，不再属于某个线程A专用。等线程A再次需要创建对象时，又会开启新的TLAB。在G1模式中，TLAB的最大大小为50% region大小。在G1模式下，多个线程对于current region的非TLAB分配操作，采用CAS来解决并发问题。





# ZGC（未来的未来）

ZGC的特点是对吞吐量影响不大的前提下，极大地降低了STW时间（10ms以内）。它和G1一样也是基于region布局，不同的是ZGC**不设分代**，采用了读屏障、染色指针、内存多重映射等技术来实现了**并发的标记压缩算法**。ZGC主要分为四个阶段：并发标记、并发预备重分配、并发重分配、并发重映射。基本上ZGC的STW时间都花在了第一步并发标记上，其他时间都是和用户线程并发执行的。

// TODO ZGC需要看更详细的文章

