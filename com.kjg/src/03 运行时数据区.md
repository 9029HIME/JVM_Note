# JVM与内存

JVM有自己的一套内存管理机制，该机制规定了Java进程运行过程中对内存的申请、分配、管理的策略，但是不同的JVM的内存管理机制有一定的差异。**其中运行时数据区可以理解为JVM所管理的主要内存区域**。对于运行时数据区的划分，可以参考下图：

![image](https://user-images.githubusercontent.com/48977889/150280032-3a1ce1cf-a056-494b-8598-8a9ab81f58f4.png)

其中代码缓存+元数据区可以理解为方法区。需要注意的是，一个JVM只会有一个运行时数据区，**JVM本身会维护运行时数据区的一个映射对象：即java.lang.Runtime对象**。

对于运行时数据区来说，可以划分为：线程私有区域、线程共享区域。

线程私有区域包括：PC、本地方法栈、虚拟机栈。

线程共享区域包括：方法区、堆。

也就是说：方法区、堆里的数据需要考虑线程安全问题，**注意！不一定是所有堆的数据都会有安全问题，毕竟虚拟机栈的一些指针可能指向堆里，但只有栈所属的线程能访问**。

# Java线程

在HotSpot虚拟机里，一个Java线程会映射为一个lwp线程，这个lwp线程会随着Java线程的创建而创建、终止而回收，这里就体现了线程池的重要性。当lwp线程初始化成功后就调用Java线程的run方法。

在JVM中除了程序线程外，还有其他的Java线程，这些线程维护着进程的运行，包括：虚拟机线程、周期任务线程、GC线程、编译线程、信号调度线程。这也是为什么用jconsole查看java进程时会发现还有其他多个线程。

# PC寄存器

这里的PC寄存器和OS的PC寄存器不是同一个东西，**可以理解为是模仿OS的，一个JVM层面的PC，在OS层面这个PC是一块内存空间**，作用是记录PC持有者（线程）下一条要执行的字节码指令的**地址**。

有以下代码：

```java
public class PcCounter {
    public static void main(String[] args) {
        int i = 10;
        int j = 11;
        int k = i + j;

        String s = "abc";
        System.out.println(i);
        System.out.println(k);
    }
}
```

通过javap -v PcCounter.class获取对应的字节码：

```
Classfile /home/kjg/projects/java/jvm_study/out/production/jvm_study/src/code/PcCounter.class
  Last modified 2022-1-24; size 644 bytes
  MD5 checksum a2a481d1ff3156207b4a69ee1c3b71f0
  Compiled from "PcCounter.java"
public class src.code.PcCounter
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#26         // java/lang/Object."<init>":()V
   #2 = String             #27            // abc
   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V
   #5 = Class              #32            // src/code/PcCounter
   #6 = Class              #33            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lsrc/code/PcCounter;
  #14 = Utf8               main
  #15 = Utf8               ([Ljava/lang/String;)V
  #16 = Utf8               args
  #17 = Utf8               [Ljava/lang/String;
  #18 = Utf8               i
  #19 = Utf8               I
  #20 = Utf8               j
  #21 = Utf8               k
  #22 = Utf8               s
  #23 = Utf8               Ljava/lang/String;
  #24 = Utf8               SourceFile
  #25 = Utf8               PcCounter.java
  #26 = NameAndType        #7:#8          // "<init>":()V
  #27 = Utf8               abc
  #28 = Class              #34            // java/lang/System
  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #30 = Class              #37            // java/io/PrintStream
  #31 = NameAndType        #38:#39        // println:(I)V
  #32 = Utf8               src/code/PcCounter
  #33 = Utf8               java/lang/Object
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               java/io/PrintStream
  #38 = Utf8               println
  #39 = Utf8               (I)V
{
  public src.code.PcCounter();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lsrc/code/PcCounter;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=5, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        11
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: ldc           #2                  // String abc
        12: astore        4
        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        17: iload_1
        18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
        21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        24: iload_3
        25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
        28: return
      LineNumberTable:
        line 5: 0
        line 6: 3
        line 7: 6
        line 9: 10
        line 10: 14
        line 11: 21
        line 12: 28
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      29     0  args   [Ljava/lang/String;
            3      26     1     i   I
            6      23     2     j   I
           10      19     3     k   I
           14      15     4     s   Ljava/lang/String;
}
SourceFile: "PcCounter.java"

```

第69-85行是PcCounter的字节码内容，其中字节码前面的数字是指令地址，即**PC寄存器存放的内容**，执行引擎从PC寄存器拿到指令地址、根据地址拿到指令内容、根据指令内容执行（最终是翻译成机器指令，让CPU去运行，之后就是OS的事了）。**执行引擎在执行指令的过程中会操作局部变量表、操作数栈等运行时数据区。**

我们来看下这段字节码的部分内容：

1.“10: ldc           #2”：从常量池中取出一个常量，符号引用为#2。

2.根据#2这个符号在常量池找到“String             #27”，从而找到符号引用#27。

3.根据#27这个符号引用在常量池找到“#27 = Utf8               abc”，即字符串“abc”。

所以指令地址为10的指令 ldc #2其实做了多个操作。

# 虚拟机栈

虚拟机栈没有GC，但会有OOM，它主要记录**方法**运行的数据，而堆主要记录存储的数据。运行数据包含：方法局部变量、部分结果（方法运行时的中间结果）、方法返回值（TODO 到底是本方法返回值，还是派生方法返回值？）。其中方法局部变量包含基本类型变量、引用类型变量。如果是基本类型则直接存储值；引用类型则存储变量的指针，这个指针指向堆的实际数据。

虚拟机栈的基本存储单位是：**栈帧**。当一个方法A被调用时，方法A会被包装成一个栈帧压入栈内，方法A结束后（return和exception）其代表的栈帧会出栈。如果方法A调用了方法B，同理方法B也会被包装成栈帧压入栈内。对于JVM栈来说：栈顶所代表的方法为“**当前方法**”。

JVM规范规定了栈的大小是可以动态扩容或固定不变，当方法嵌套调用太多时，比如MethodA调用MethodB，MethodB又调用MethodA，大量的栈帧压入栈内，当栈内栈帧数超过虚拟机栈的大小后会抛出StackOverFlow异常。如果设置栈为动态大小，当JVM对栈进行动态扩容时发现内存不足（毕竟栈本质是内存空间）后会抛出OutOfMemory异常。对于栈设置可以通过**JVM参数**改动。

![2e9d06e558f7dbfc8d8dadb0bd78ca3](https://user-images.githubusercontent.com/48977889/152633683-0dacd92d-4bb1-43be-869f-b714425b28c9.png)

作为虚拟机栈的基本存储单位，栈帧包含：

1.局部变量表

2.操作数栈

3.动态链接

4.方法返回地址（TODO 是本身的返回地址，还是派生的返回地址？）

5.附加信息

## 局部变量表

用来存储方法的局部变量、方法传参，它的本质是一个**一维数组**。它可以存储基本数据类型、引用类型、返回地址。局部变量表的大小在编译器就确定下来了。

局部变量表的基本存储单位是slot，一个slot最大能存放32位的数据。其中byte、short、char在局部变量表里存储时会转为int，boolean也会转为int：0=false，非0=true。有以下代码：

```java
public class LocalVariables {
    public static void main(String[] args) {
        int i = 123;
        LocalVariables localVariables = new LocalVariables();
        double d = (double) 23.2342;
        int j = 456;
    }
}
```

通过javap -v可以获取到main方法的栈信息

![b51e1adaedc99461453940690a996ab](https://user-images.githubusercontent.com/48977889/152634475-dc2603b9-fdd6-498a-b09d-2ea321b21421.png)

可以看到这段代码中main方法所对应的栈帧M局部变量表的大小=6，首先第一个slot的数据是参数args，它是一个String数组，第二个slot存放局部变量i，因为它是32位的，所以占用一个slot。第三个slot存放局部变量localVariables，它是一个引用类型（指向堆中的对象），所以也占用一个slot。重点是第四个slot存放局部变量d，由于它是double型，需要占用两个slot，**因此d实际上是占用了索引等于3和4两个slot**。这也是为什么最后一个局部变量**j占用的slot索引是5**。

值得注意的是：如果这个方法是对象方法或构造方法，方法的会默认带一个this参数，即对象本身，这个this会存放在局部变量表的第一个slot里，如以下代码：

```java
public class LocalVariables {
    public static void main(String[] args) {
        int i = 123;
        LocalVariables localVariables = new LocalVariables();
        double d = (double) 23.2342;
        int j = 456;
        localVariables.testThis(999);
    }

    public void testThis(int x){

    }
}
```

![345399e574ba49107287f8bf39b2f8c](https://user-images.githubusercontent.com/48977889/152667261-b23958b6-4d80-4790-aec8-fceb2e9e74e7.png)

![7c7929f9aa1378869b3974cc2bcfc92](https://user-images.githubusercontent.com/48977889/152667263-98ecdce7-b018-493e-a722-1b7ccd978400.png)

可以看到默认构造方法和testThis方法都包含一个this的局部变量，它都是存放在第0个slot里。

Slot也会被重复利用，有些变量的作用域不是整个方法周期，可能在方法内部的一小段周期内就用完了，在这之后声明的变量可以被插入到过期变量生前存放的slot内，当然，这一步也是编译器决定的。如以下代码：

```java
public void testSlotCircle(){
    int a = 123;
    {
        int b = a + 1;
        // 如果不用b的话，编译器会优化掉这段代码，当作不存在
        System.out.println(b);
    }
    int c = a + 2;
}
```

![be76da326c64f5bb75cdf0227026e0e](https://user-images.githubusercontent.com/48977889/152667264-3747a3ad-9580-4578-a6ee-526a3d9413b9.png)

可以看到b原先占用index= 2的slot，后来生命周期结束后，作用域外的c变量也插入到index=2的slot内。

## 操作数栈

# 堆

正常情况下，堆是运行时数据区最大的区域。