# 标记阶段

要回收垃圾，首先要确定哪些是垃圾对象。

## 引用计数器算法

1. 比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
2. 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
3. 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
4. 缺点：
   1. 它需要单独的字段存储计数器，这样的做法增加了**存储空间的开销**。
   2. 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了**时间开销**。
   3. 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，**导致在Java的垃圾回收器中没有使用这类算法**。

## 可达性分析算法

![cc31973c82aa85437defd5de391e581](https://user-images.githubusercontent.com/48977889/158817139-0a1052c4-d4a0-4bfd-a960-6cada65626b3.jpg)

JVM规定一组**引用**集合，这个集合被称为GC Roots。以GC Roots为起点自上而下搜索根对象集合所连接的目标对象是否可达，如果可达则对象存活，不可达则垃圾对象。比起引用技术法，可达性分析算法能解决循环引用的问题。**不过要注意！！GC Root本质是一组引用，可以理解为二级指针，不是对象，它并非存在堆内**，如图：

![915fa696d1867888fafe591fdf07ce4](https://user-images.githubusercontent.com/48977889/158816831-5d45595d-895e-4645-a05a-52d3b5f0f767.jpg)

GC Roots包含以下范围：
1.虚拟机栈、本地方法栈存放的引用，如局部变量表存放的引用
2.静态属性的引用
3.静态常量属性的引用
4.等等...
总的来说，不在堆空间的引用都可以作为GC Roots的一部分。但除了这些固定的GC Roots外，有些垃圾回收器会根据回收区域不同，**将一些堆内的引用临时加入GC Roots内**，比如只针对eden区的垃圾回收。如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

# Finalize

垃圾回收期在标记对象后，销毁对象前，会调用这个对象的Object::finalize()方法，调用完成后再判断这个对象是否值得被销毁，如果对象变得可达，则不标记销毁，反之则继续销毁。通常finalize()方法是用来销毁对象前做一些资源关闭处理，有点类似C++的析构函数。不过深入理解Java虚拟机说过：**finalize()设计之初是为了满足C/C++开发人员的习惯。所以在日常的开发中，关闭资源还是在finally代码块里写比较好。**
具体的finalize过程：
1.在可达性分析后，发现GC Roots到对象a没有引用链，标记对象a为**不可达状态**。
2.对象a是否重写了finalize() ? 进入第三步 : 等待被销毁
3.对象a是否执行过finalize() ? 进入不可达状态 : 进入**可复活状态**，进行第四步
4.将对象a插入F-Queue内，一个由虚拟机创建的、低优先级的Finalizer线程会根据队列顺序，执行对象的finalize()方法。
5.执行完对象a的finalize()方法后，垃圾回收器会对对象a进行第二次标记，如果发现对象a在GC Roots上可达，则将对象a移出垃圾对象集合，并把对象a标记为**可达状态**。如果不可达，则标记为**不可达状态**。

**从头到尾，1个对象finalize()要么不执行，要么就只执行1次。**

# 清除阶段

首先要搞明白，标记阶段是明确**哪些对象是存活对象**，毕竟垃圾对象在很多时候是无法确定的。标记实际上就是往**非垃圾对象**的对象头上标识一个**可达状态**，之后就是清除了。清除阶段主要是对堆中（**或者GC范围中**）的对象进行线性遍历，如果发现这个对象的对象头状态记录**不是可达状态**，就认为它是垃圾对象。目前主流用到三种清除算法：标记清除（Mark-Sweep）、标记复制（Mark-Copy）、标记压缩（Mark-Sweep-Compact）

## 标记清除

分为两个**整体**的流程：标记和清除。首先通过标记算法标记出哪些对象可达，这是第一次循环。然后再从根节点为起点，遍历堆中（或者GC范围中）的对象，当发现这个对象**不是可达状态**时，释放这个对象的空间，这是第二次循环。如图：

![60e2658965b531f8698ce60937975fb](https://user-images.githubusercontent.com/48977889/159280510-e715d37f-013b-473c-8240-b9c20aac36d9.jpg)

实际上，这里的清除并非物理上释放内存空间，而是标记这块内存区域为可用，**等下次需要对象赋值时，直接覆盖这块区域**。总的来看标记清除算法的时间复杂度是O(2n)，这也导致了STW时间更长。优点是简单方便，缺点就是效率偏低，而且会造成内存碎片。

## 标记复制

标记复制算法需要划分两块内存区域，同一时间段内只能使用其中一块内存区域，另一外内存区域置空。在进行**标记复制**回收时，先从根节点开始遍历，将遍历到的对象采用**指针碰撞**的方式移动到另一块内存区域内，遍历结束后**需要改变原有二级指针记录的存活对象地址（毕竟换了一个内存区域）**，释放原先内存区域的垃圾对象空间，同时**交换两块内存区域的角色**。如图：

![03d1d24c386a987c753521f85d09474](https://user-images.githubusercontent.com/48977889/159280999-b7583b0f-5835-4c21-904f-1e9ec0b74731.jpg)

比起标记清除算法，标记复制算法的优点体现在：减少了一次循环，相当于减少了STW的时间。并且不会产生内存碎片，毕竟存活对象转移到另一块区域时用的是指针碰撞。缺点是浪费了一块内存区域，**并且不适用于存活对象多的场景（存活对象越少，效率越高）**。

## 标记压缩

标记压缩算法和标记清除算法有点类似，也是需要两步，分别是标记和压缩。首先通过标记算法标记出哪些对象可达，这是第一次循环。接着通过**压缩算法**将存活对象紧密地排列在一起，随后清除**标记范围里，其他区域的所有对象**（都是垃圾了），然后改变原有二级指针记录的存活对象地址，最后JVM会为**标记范围**维护一个起始地址，下次分配对象时根据起始地址碰撞就能得出新对象的地址了。

值得一提的是，这里的**压缩算法**只是一笔带过，实际上在标记结束后，不是简单地再次遍历，然后压缩，**其实是有一番讲究的**。总之最终的效果和标记复制算法一样，没有产生内存碎片，但和标记清除又有点像，都是只用一块内存区域来完成GC。但是缺点也很明显，首先是效率问题，**压缩算法**是一个比较复杂的过程，不好的压缩算法会导致STW时间很长。总体上来看，标记压缩算法是三个算法里效率最低的。

## 三种算法的对比

|              | 标记清除           | 标记整理           | 复制                                  |
| ------------ | ------------------ | ------------------ | ------------------------------------- |
| **速率**     | 中等               | 最慢               | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片）   | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是（需要更换地址） | 是（需要更换地址）                    |



# 分代收集算法

三种清除算法都有它的优缺点，为了充分发挥各自的优越性，JVM根据**对象存活时间、垃圾对象数量**对堆内存划分了年轻代、老年代两个区域，对不同区域采取不同的清除算法。对于年轻代来说，大部分对象都在这里创建，并且朝生暮死，这意味着年轻代在同一时间范围内的垃圾数量要比老年代要多；这种时候采用标记复制算法是收益最高的，eden → s1 ↔ s2之间**在逻辑上形成了标记复制算法的两块内存区域**。至于老年代的对象，它们在s1 ↔ s2经历了15次swap后，基本上是不会被销毁的了，因此垃圾对象的数量相对较少，采用标记清除+标记压缩算法来回收，收益会更高。

实际上，JVM对老年代使用CMS垃圾回收器进行回收，CMS实际使用**标记清除算法**。当发现内存碎片情况严重时，JVM会使用以标记整理算法为基础的**Serial Old垃圾回收器**进行回收，属于是**兜底方案**。

# 增量收集算法

上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在**Stop the World**状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。

**增量收集算法基本思想**

1. 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。**每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。**
2. 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过**对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作**

**增量收集算法的缺点**

使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，**造成系统吞吐量的下降**。

# 分区算法

​	**是G1收集器使用的算法**。一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

![image](https://user-images.githubusercontent.com/48977889/159491460-9f51f6aa-7788-4177-9349-06c2461d541f.png)

分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

# 注意 

实际上，上面讲了很多算法，其中清除阶段的算法是**基础算法**，分代、增量、分区是堆基础算法的一种**运用策略**。然而**实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。**
