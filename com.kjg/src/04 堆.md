# 堆

堆是由JVM管理的、属于进程级别的连续逻辑内存空间，它可以被多个线程共享（有一致性问题）。Java作为一门面向对象语言，许多对象都是直接分配在堆空间内，因此GC也是发生在堆上，通过GC可以动态释放堆内无用的内存空间。堆在JVM启动时就被创建，可以根据参数的设置在JVM运行期间动态扩容。

作为GC的主要场所，堆划分了以下多个区域(JDK8之后)：

1.新生区：包含Eden区和Survivor区，Survivor区又分为1区和2区

2.养老区

3.元空间

![image](https://user-images.githubusercontent.com/48977889/154623197-3184f4b2-371c-4b72-b7ef-5c4017d98f52.png)

通过jvisualvm工具，可以看到Java进程的堆空间信息，有以下代码：

```java
public class HeapTest {
    public static void main(String[] args) throws InterruptedException {
        while(true){
            Thread.sleep(1000000);
        }
    }
}
```

代码内容不是重点，主要是看堆空间的情况，设置这个Java进程的VM参数-Xms10m -Xmx10m。然后通过jvisualvm命令打开可视化界面，点击visual GC，可以看到：

![image](https://user-images.githubusercontent.com/48977889/154632153-4c4834cf-4a7e-4cb8-a3f9-627f827e734d.png)

新生区养老区刚好10M，其实通过Xms、Xmx设置的堆空间大小，不包含元空间。一般情况下，Xms和Xmx都会设置成一样大小，**是为了避免频繁的内存扩容、缩减**。

还是同一套代码，我们可以通过jstat -gc $进程id来查看堆空间使用情况：

![image](https://user-images.githubusercontent.com/48977889/154635416-ed5548a7-25c1-4151-aa04-b34d8e71218c.png)

分区名称+C：该分区总空间大小

分区名称+U：该分区已用空间大小

实际上，**S0和S1只能有一个被使用**（后面详讲）

# 年轻代和老年代

对象在JVM内存中可以划分为两类：短生存周期对象、长生存周期对象。其中长生存周期对象甚至贯穿了整个JVM生存周期，如Sring部分加载进IOC容器的对象。实际上大部分对象在eden区就会被GC回收了，剩下的在eden没有被GC的对象会被移到幸存者区。再每一次GC时，如果幸存者区的对象没有被回收，则会放进另外一个幸存者区，当来回转换一定的次数后，剩下还没被回收的对象就会被放进老年代。

![deda2be9cc2c3724a544e10c9e50321](https://user-images.githubusercontent.com/48977889/154916495-b221e9f7-1ef0-40bd-aa32-ef8c47d32547.jpg)

# 对象分配过程

![70ccbb2edead0bdcdc26d6016be3908](https://user-images.githubusercontent.com/48977889/155069453-86ce3c80-f9a1-4f5d-9118-64390a94b78f.png)

对象优先放进eden区，**只有**当eden区满的时候，触发Young GC/Minor GC。如图所示：eden区已经被占用了5个对象（满员），此时再创建一个对象明显空间不足，于是触发Young GC/Minor GC。通过**垃圾回收算法（后面会讲扫描过程）**扫描出3个对象是垃圾对象，即红色的3个，此时释放这3个垃圾对象的内存空间。剩下2个仍被使用的对象则放进s0。**JVM为每个对象都设置一个age值**，默认=0，当经过Young GC/Minor GC后幸存下来的对象会被转移空间，每转移1次age值增加1。此时s0中的两个对象age值就变为1了。接下来eden区就有足够的空间创建新对象。

![96b9f62ed33dafa4e3eaf106edbe494](https://user-images.githubusercontent.com/48977889/155069474-677cbac0-5fbd-4da6-863a-16f9643cd17c.png)

当eden区又满了后，触发Young GC/Minor GC，此时eden区被扫描出4个垃圾对象，1个幸存对象，**同时还会扫s0区**，发现s0区都是幸存对象。然后将eden区的幸存对象和s0区的幸存对象都转移到S1区，同时age+1。上面说到s0和s1是来回互转的，同一时刻只有一个区持有对象、另一区为空。JVM规定当前持有对象的幸存者区为from区，反之为to区。**from和to是不停变换的**。

![90c5c4d43af4df7c588bc131b948606](https://user-images.githubusercontent.com/48977889/155069487-1829047c-bd6c-43b6-ac32-af4293d289a1.png)

在幸存者区来回转移时，如果发现对象的age=15，则会将age直接移到老年代。这个age阈值可以通过参数设置，默认为15。

实际上，对象的分配过程也有特殊情况，有些时候即使触发了Young GC/Minor GC，新对象也不一定会放在eden区里。具体的逻辑伪代码如下：

```
if	eden区有足够空间：

​	直接放进eden区;

else:

​	进行YGC/MGC;

​	if	eden区有足够空间:

​		直接放进eden区;

​	else:

​		// 说明eden区全是有用对象，**幸存者区也全是有用对象（年龄未到阈值）**

​		if	老年代空间充足：

​			新对象放进老年代;

​		else：

​			进行Full GC;

​			if	老年代空间充足：

​				新对象放进老年代;

​			else：

​				throw OOM;			
```

可以看到，在特殊场景下，一些新对象会直接放进老年代里。

# GC分类
