# 堆

堆是由JVM管理的、属于进程级别的连续逻辑内存空间，它可以被多个线程共享（有一致性问题）。Java作为一门面向对象语言，许多对象都是直接分配在堆空间内，因此GC也是发生在堆上，通过GC可以动态释放堆内无用的内存空间。堆在JVM启动时就被创建，可以根据参数的设置在JVM运行期间动态扩容。

作为GC的主要场所，堆划分了以下多个区域(JDK8之后)：

1.新生区：包含Eden区和Survivor区，Survivor区又分为1区和2区

2.养老区

3.元空间

![image](https://user-images.githubusercontent.com/48977889/154623197-3184f4b2-371c-4b72-b7ef-5c4017d98f52.png)

通过jvisualvm工具，可以看到Java进程的堆空间信息，有以下代码：

```java
public class HeapTest {
    public static void main(String[] args) throws InterruptedException {
        while(true){
            Thread.sleep(1000000);
        }
    }
}
```

代码内容不是重点，主要是看堆空间的情况，设置这个Java进程的VM参数-Xms10m -Xmx10m。然后通过jvisualvm命令打开可视化界面，点击visual GC，可以看到：

![image](https://user-images.githubusercontent.com/48977889/154632153-4c4834cf-4a7e-4cb8-a3f9-627f827e734d.png)

新生区养老区刚好10M，其实通过Xms、Xmx设置的堆空间大小，不包含元空间。一般情况下，Xms和Xmx都会设置成一样大小，**是为了避免频繁的内存扩容、缩减**。

还是同一套代码，我们可以通过jstat -gc $进程id来查看堆空间使用情况：

![image](https://user-images.githubusercontent.com/48977889/154635416-ed5548a7-25c1-4151-aa04-b34d8e71218c.png)

分区名称+C：该分区总空间大小

分区名称+U：该分区已用空间大小

实际上，**S0和S1只能有一个被使用**（后面详讲）

# 年轻代和老年代

对象在JVM内存中可以划分为两类：短生存周期对象、长生存周期对象。其中长生存周期对象甚至贯穿了整个JVM生存周期，如Sring部分加载进IOC容器的对象。实际上大部分对象在eden区就会被GC回收了，剩下的在eden没有被GC的对象会被移到幸存者区。再每一次GC时，如果幸存者区的对象没有被回收，则会放进另外一个幸存者区，当来回转换一定的次数后，剩下还没被回收的对象就会被放进老年代。

![deda2be9cc2c3724a544e10c9e50321](https://user-images.githubusercontent.com/48977889/154916495-b221e9f7-1ef0-40bd-aa32-ef8c47d32547.jpg)



