# 元空间

在JDK8之前，元空间被称为方法区，JDK8以后才改为元空间。JVM规范规定元空间在逻辑上是堆的一部分，然而HotSpot虚拟机在实现上把它们区分开了，结合04 堆.md的笔记也可以看到设置堆空间大小和元空间没有关系。

![39a51dd38d3e8770f89770acab76318](https://user-images.githubusercontent.com/48977889/155983897-59e7c9f3-05b8-4bfa-95f3-08b356a4bc50.png)

相比堆，元空间是存储类相关的信息，如类变量、类定义、类方法，里面的信息大部分由类加载器加载进JVM时生成。如果Java进程中声明的类（或匿名内部类）过多， 会导致元空间OOM。元空间内存储着**类信息、域信息、方法信息、常量、静态变量、JIT后的代码缓存**等信息。

**类信息**包括1.类的全类名、2.直接父类的全类名、3.类的实现接口信息。

**域信息**包括这个类声明的变量名称、变量类型、修饰符。

**方法信息**包括这个类的方法修饰符、方法名称、返回值类型、参数。甚至还有方法体的字节码、方法对应的操作数栈、局部变量表的大小、异常表的内容。

总的来说，类信息、域信息、方法信息有点像class对象的信息，**都是是停留在类的层面**。

其实通过javap -v 类名.class获取的就是字节码文件通过类加载器加载到方法区**之前**的类信息。

**静态变量**是和类关联的，随着类的加载而加载，类变量能被类派生的所有实例共享，哪怕这个实例是null，静态变量在**准备**阶段赋0值，在**初始化**阶段显式赋值。

**静态常量**（static final）在编译时就会被写死在字节码文件中，在**准备**阶段显式赋值。

# 运行时常量池

运行时常量池是元空间的一部分。每一个字节码文件都会有一个自身的**常量池**，自身的常量池存放着本类的各种字面量与符号引用。一个类中需要的数据如引入的类，调用的函数，字符串常量等类信息是很多的，如果每一个类的字节码文件里都维护这些数据的话，字节码文件会变得十分臃肿。因此字节码采用常量池的方式对自身的各种字面量采用**符号引用**方式在常量池声明。字节码被类加载器加载到元空间后会根据**常量池**在元空间维护一份**运行时常量池**，每一个类都有一份自身的**运行时常量池**，但多个类通过运行时常量池找到的类信息**可能是同一份**的。

打个比方，A类和B类都调用了sout方法，执行引擎先通过**getstatic #符号**的符号引用在**A的运行时常量池**查找System类和PrintStream(out)类是否被加载到元空间，如果没有则加载，有的话直接通过**#符号**在**A的运行时常量池**里找到System和PrintStream类。B也是同理，只不过A和B找到的类信息实际上是同一份。

# 元空间的特性

![image](https://user-images.githubusercontent.com/48977889/156301995-e076d963-deb8-4734-976c-8affeb08441e.png)

首先要明白，方法区只是JVM规范中声明的概念，但在HotSpot虚拟机实现中，把方法区这个概念具象化为元空间。在JDK8后，元空间实际上划分在物理机的本地内存上，和虚拟机内存隔开。这样做的目的是方法区本身是存储类信息的地方，在java进程运行的过程中会动态加载很多类，**这也导致方法区很难确定大小**，如果方法区在堆空间内，在设置堆空间参数时还需要为方法区设置一个大小。设置得太大会浪费空间，设置的太小又比较难GC（方法区只能通过Full GC回收）。

所以元空间在本地内存中分配，**本地内存可以动态分配大小，最大可分配空间就是系统可用内存空间**，就解决了方法区在堆内存中的分配难题。

不过在JDK8以后，静态变量和字符串常量池就移到了堆中，而不是元空间。因为Java进程在运行的过程中会产生很多个字符串，它是一个常变、经常增加的池，如果放在元空间中则会影响回收效率（只能通过Full GC回收），**而放在堆里能及时回收**。

至于静态变量，来看以下代码：

```java
package com.atguigu.java1;

/**
 * 《深入理解Java虚拟机》中的案例：
 * staticObj、instanceObj、localObj存放在哪里？
 */
public class StaticObjTest {
    static class Test {
        static ObjectHolder staticObj = new ObjectHolder();
        ObjectHolder instanceObj = new ObjectHolder();

        void foo() {
            ObjectHolder localObj = new ObjectHolder();
            System.out.println("done");
        }
    }

    private static class ObjectHolder {
    }

    public static void main(String[] args) {
        Test test = new StaticObjTest.Test();
        test.foo();
    }
}
```

毫无疑问，staticObj、instanceObj、localObj**指向的对象**都是存放在堆里的，值得注意的是foo()如果不是热点代码，没有被JIT处理，就不会标量替换，因此还是存放在堆里的。那么staticObj、instanceObj、localObj这三个引用本身存放在哪里呢？instanceObj是放在**堆空间中，test对象实例的一块区域内**，localObj是放在foo栈帧的局部变量表里，而staticObj则是存放在Test类的class对象实例（要记住，同一个类的class对象是单例的）的一块区域内，**所以本质还是在堆上**。

