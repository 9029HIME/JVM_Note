# 元空间

在JDK8之前，元空间被称为方法区，JDK8以后才改为元空间。JVM规范规定元空间在逻辑上是堆的一部分，然而HotSpot虚拟机在实现上把它们区分开了，结合04 堆.md的笔记也可以看到设置堆空间大小和元空间没有关系。

![39a51dd38d3e8770f89770acab76318](https://user-images.githubusercontent.com/48977889/155983897-59e7c9f3-05b8-4bfa-95f3-08b356a4bc50.png)

相比堆，元空间是存储类相关的信息，如类变量、类定义、类方法，里面的信息大部分由类加载器加载进JVM时生成。如果Java进程中声明的类（或匿名内部类）过多， 会导致元空间OOM。元空间内存储着**类信息、域信息、方法信息、常量、静态变量、JIT后的代码缓存**等信息。

**类信息**包括1.类的全类名、2.直接父类的全类名、3.类的实现接口信息。

**域信息**包括这个类声明的变量名称、变量类型、修饰符。

**方法信息**包括这个类的方法修饰符、方法名称、返回值类型、参数。甚至还有方法体的字节码、方法对应的操作数栈、局部变量表的大小、异常表的内容。

总的来说，类信息、域信息、方法信息有点像class对象的信息，**都是是停留在类的层面**。

其实通过javap -v 类名.class获取的就是字节码文件通过类加载器加载到方法区**之前**的类信息。

**静态变量**是和类关联的，随着类的加载而加载，类变量能被类派生的所有实例共享，哪怕这个实例是null，静态变量在**准备**阶段赋0值，在**初始化**阶段显式赋值。

**静态常量**（static final）在编译时就会被写死在字节码文件中，在**准备**阶段显式赋值。

# 运行时常量池

运行时常量池是元空间的一部分。每一个字节码文件都会有一个自身的**常量池**，自身的常量池存放着本类的类信息、类所声明的字面量。一个类中需要的数据如引入的类，调用的函数，字符串常量等类信息是很多的，如果每一个类的字节码文件里都维护这些数据的话，字节码文件会变得十分臃肿。因此字节码采用常量池的方式对自身的类信息、字面量采用**符号引用**方式在常量池声明。字节码被类加载器加载到元空间后会根据**常量池**在元空间维护一份**运行时常量池**，每一个类都有一份自身的**运行时常量池**，但多个类通过运行时常量池找到的类信息**可能是同一份**的。

打个比方，A类和B类都调用了sout方法，执行引擎先通过**getstatic #符号**的符号引用在**A的运行时常量池**查找System类和PrintStream(out)类是否被加载到元空间，如果没有则加载，有的话直接通过**#符号**在**A的运行时常量池**里找到System和PrintStream类。B也是同理，只不过A和B找到的类信息实际上是同一份。

