# JMM和JVM

结合之前学的JVM可以了解到，JVM规范将Java内存划分成了多个区域，那么JMM又是什么呢？JMM虽然叫Java Memory Model，但本质和JVM的内存划分策略不一样，而是规定**多个线程操作JVM内存的策略与规范**。

JMM对于内存的定义有两种：主内存与工作内存。主内存即JVM对于多个线程的共享内存。
主内存：可以理解为堆内存与堆外内存（元空间），即多个线程共同操作的区域。
工作内存：存储线程执行的当前方法的所有本地变量信息，这个本地变量信息是主内存中的变量副本拷贝。每个线程只能访问自己的工作内存，线程对自己工作内存的修改对其他线程是不可见的。对于多个线程来说，他们之间的通讯还是依赖于主内存。

# JMM概述

JMM规定了所有线程在操作主内存变量时，先把主内存变量拷贝到自己的工作内存，然后操作工作内存里的变量，不能碰主内存的。如果操作过程中涉及到变量的更改，则操作完成后会将工作内存的变量刷写回主内存。

这里就引出一个问题：当时在JVM学习过程中可以知道，如果操作的是引用类型数据的话，线程的虚拟机栈的局部变量表里存储的是引用数据的指针，那么和JMM的说法就冲突了？

实际上，虽然存的是指针，但实际操作这个对象的时候线程会通过指针找到主存里的对象，然后将对象拷贝一份副本到自己的工作内存里。不过当操作的对象大小＞1MB时，线程只会拷贝自己要操作的那一部分。

# 指令重排与serial语义

# 可见性

# volatile如何避免指令重排

# volatile如何保证可见性

# 没有volatile，一定会出现可见性问题嘛？

# 为什么只用volatile，数据会不同步？不是已经保证可见性了嘛？

# double check问题，会有什么后果，为什么有synchonized了还会出现这个问题？

