# 对象初始化过程

以一个最简单的例子为例：

```java
public class Test {
    public static void main(String[] args) {
        Object obj = new Object();
    }
}
```

对应的关键字节码：

```
         0: new           #2                  // class java/lang/Object
         3: dup           
         4: invokespecial #1                  // Method java/lang/Object."<init>":()V
         7: astore_1
         8: return
```

执行引擎在执行new指令时会先根据符号引用#2找到要初始化的类java/lang/Object，然后检查这个类是否已经被加载、解析、初始化，简单来说就是看这个类是否在元空间内存在。如果存在，则进行初始化。如果不在，则在双亲委派模式的前提下，对这个类进行**类加载**。

在堆内存初始化对象时，先计算对象占用的**空间大小**，如果对象包含基本数据类型，那么很容易算出来一个属性的大小；如果是引用类型，属性实际存的是指针，那也能算出来大小。明确了大小后，就是选择**分配方式**了，有以下两种情况：

内存规整：采用指针碰撞分配内存

- 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
- 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。
- 如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
- 标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域

内存不规整

- 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
- 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”
- 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
- 标记清除算法清理过后的堆内存，就会存在很多内存碎片。

**上面的做法有点像OS的虚拟内存管理，至于是交给OS来做，还是JVM自己来做，暂时还没研究到。**

确定了分配方式后，**就要处理并发问题了**，这里的并发问题指的是多个线程创建对象时可能会竞争同一块内存空间的问题，之前也讲过，要么TLAB，要么CAS。

为对象分配了一块堆内存空间后，接下来就是给对象的**成员变量赋0值**。赋予0值后**再为对象设置对象头**。

设置完对象头后，就该为**成员变量赋值**了。第一步根据显示值赋值，并且执行对象代码块，这两者按照声明顺序来执行；第二步执行构造器方法。最终**将对象的首地址赋予给引用变量**。

总的来说，对象初始化过程可以按顺序分为这几步：

1.检查所属类是否已加载，没有则加载。

2.计算空间大小。

3.选择分配方式。

4.在并发安全的前提下分配内存。

5.赋0值。

6.设置对象头。

7.显示赋值/执行代码块（看声明顺序），然后执行构造器方法（就是上面字节码的invokespecial #1）。

值得注意的是：创建对象时，也会创建父类的属性，只不过父类的成员变量是在子类所属的堆区域内，父类成员变量在前，子类成员变量在后，属于包含关系，并非同级的父对象、子对象关系。



# 对象内存结构

类型指针指向的是这个类的klass对象，这个对象存在元空间（其实也就是堆）中。

对象填充使对象的大小总是8字节的倍数，方便CPU读取